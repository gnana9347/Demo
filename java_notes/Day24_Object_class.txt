Object class :
=============
Object is a one of predefind java class which is developed by java people. it is act like a master super class or all java classes or
 every class should be a sub class to object class either direct or indirect. 

Object class is present in java.lang package. here java.lang package is declared as a default package for all java clsses 
so what ever the classes are present in java.lang package we can use directly without import statements.

important classes in java.lang pkg :

Object 
System 
String 
StringBuffer
StringBuilder

Byte
Short
Integer
Long
Float
Double
Boolean
Charactor 

Object.java
============
package java.lang;
public class Object{
   // Object class members
   public Object(){
   
   }
}

Objec class members:
====================

1 No arg Constructor : 
public Object(){
   
   }
   
   object class having only one constructor i.e no arg constructor or defualt constructor.
 Methods:
=========== 
 1. toString()
 2. equals()
 3. hashCode()
 4. clone()
 5. finalized()

these 5 methods are very imprtant methods for all java classes 

6. wait()
7. notify()
8. notifyAll()

these 3 methdos we will use it only for Thread class

lets start with 
 1. toString(): toString method will convert any object value into a String format.
     syntax :
	    public String toString(){
		}
		
  as per the Object class toString() will give the output of any object is : 
   "fullyQualifiedclassName"+"@"+ "ObjectMemoryLocation in hexa decimal format"
   
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
   
   here :  getClass().getName() : will give out put as fullyQualifiedclassName
           hashCode(): this will give object memory location in int format
		  Integer.toHexString(hashCode()): he will convert int value into hexa format 
		  
  sample output :  com.k7it.Person@2dda6444
  
  
  
  public class Person {

	private int age;
	private String name;
	private double ht;
	private double wt;
	public static Address address = new Address(10,"4th cross","Balari","KA","IND",560023);

	public Person() {
		super();
	}

	public Person(int age, String name, double ht, double wt, Address address) {
		super();
		this.age = age;
		this.name = name;
		this.ht = ht;
		this.wt = wt;
		this.address = address;
	}
}

public class Address {
	private int doorNo;
	private String street;
	private String city;
	private String state;
	private String country;
	private int pincode;

	// no arg constructor
	public Address() {
		super();
	}

// all argument constructor 
	public Address(int doorNo, String street, String city, String state, String country, int pincode) {
		super();
		this.doorNo = doorNo;
		this.street = street;
		this.city = city;
		this.state = state;
		this.country = country;
		this.pincode = pincode;
	}
public class Address {
	private int doorNo;
	private String street;
	private String city;
	private String state;
	private String country;
	private int pincode;

	// no arg constructor
	public Address() {
		super();
	}

// all argument constructor 
	public Address(int doorNo, String street, String city, String state, String country, int pincode) {
		super();
		this.doorNo = doorNo;
		this.street = street;
		this.city = city;
		this.state = state;
		this.country = country;
		this.pincode = pincode;
	}
}

public class ObjectClsDemo extends Object{

	public static void main(String[] args) {
		Person p1 = new Person();
		p1.setAge(10);
		p1.setName("Tharun");
		p1.setHt(5.5);
		p1.setWt(60.25);
		
		Address a1 = new Address();
		a1.setDoorNo(17);
		a1.setStreet("3rd cross");
		a1.setCity("Blr");
		a1.setState("KA");
		a1.setCountry("IND");
		a1.setPincode(560043);
		
		p1.setAddress(a1);
		
		Person p2 = new Person(24,"Sahana",5.5,55.25,new Address(10,"4th cross","Balari","KA","IND",560023));
		
		Address a2 = new Address(10,"4th cross","Balari","KA","IND",560023);
		Person p3 =  new Person(25,"babu",5.6,55.0,a2);
		Person p4 =  new Person(25,"Prasad",5.6,55.0,a1);
		
		String str1  = "good morning";
		String str2  = new String ("good morning");
		
		System.out.println(str1);// Goomorning 
		System.out.println(str2);// Goomorning 
		
		System.out.println(p1);
		System.out.println(p2);
		System.out.println(p3);
		System.out.println(p4);
		System.out.println(a1);
		System.out.println(a2);
		
		
	//	Person.address.
		
	}
}

output: 

good morning
good morning
com.k7it.Person@2dda6444  -> this output is generated by toString() of object class 
com.k7it.Person@5e9f23b4
com.k7it.Person@4783da3f
com.k7it.Person@378fd1ac
com.k7it.Address@49097b5d
com.k7it.Address@6e2c634b

Note: what ever the object if are trying to print using sop statements it will convert into objref.toString();

		System.out.println(str1);
		System.out.println(str2);		
		System.out.println(p1);
		System.out.println(p2);
		System.out.println(p3);
		System.out.println(p4);
		System.out.println(a1);
		System.out.println(a2);
		
		System.out.println(str1.toString()); //good morning
		System.out.println(str2.toString());//good morning		
		System.out.println(p1.toString());// com.k7it.Person@2dda6444 
		System.out.println(p2.toString());//com.k7it.Person@5e9f23b4
		System.out.println(p3.toString());// com.k7it.Person@4783da3f
		System.out.println(p4.toString());//com.k7it.Person@378fd1ac
		System.out.println(a1.toString());//com.k7it.Address@49097b5d
		System.out.println(a2.toString());//com.k7it.Address@6e2c634b
		
		Note: as per the Object class toString method it will give the output like 
		 class name and object memory location in hexa decimal format,

		 but as a java developer we should not concentrate much on object memory
		location, we should concentrate on object values or object content or  object state.
		
		so if want to print values of the object instead of memory location of objects 
		then we should override toString() inside our class. 
		
		
		first override toString() in person clas like bellow:
		
		public String toString() {
		return "Age:"+age+",Name:"+name+",Ht:"+ht+",Wt:"+wt+",Address:"+address.toString();
	}
		 output of above program:
		 ===========================
		good morning
		good morning
		Age:10,Name:Tharun,Ht:5.5,Wt:60.25,Address:com.k7it.Address@2dda6444
		Age:24,Name:Sahana,Ht:5.5,Wt:55.25,Address:com.k7it.Address@2dda6444
		Age:25,Name:babu,Ht:5.6,Wt:55.0,Address:com.k7it.Address@2dda6444
		Age:25,Name:Prasad,Ht:5.6,Wt:55.0,Address:com.k7it.Address@2dda6444
		com.k7it.Address@2dda6444
		com.k7it.Address@728938a9

   here person class direct attributes are printing values but address class attribute printing again class name and hexa decimal value. to avoid this means we need to override toString() inside Address
   class as well.
   
   @Override
	public String toString() {
		return "Address [doorNo=" + doorNo + ", street=" + street + ", city=" + city + ", state=" + state + ", country="
				+ country + ", pincode=" + pincode + "]";
	}
	
	here we are addign override toString method using eclipse it will generate toString() automatically with all of our clas attributes like above. 
	
	after this changes abobe program output will be :
	
	good morning
good morning
Age:10,Name:Tharun,Ht:5.5,Wt:60.25,Address:Address [doorNo=17, street=3rd cross, city=Blr, state=KA, country=IND, pincode=560043]
Age:24,Name:Sahana,Ht:5.5,Wt:55.25,Address:Address [doorNo=17, street=3rd cross, city=Blr, state=KA, country=IND, pincode=560043]
Age:25,Name:babu,Ht:5.6,Wt:55.0,Address:Address [doorNo=17, street=3rd cross, city=Blr, state=KA, country=IND, pincode=560043]
Age:25,Name:Prasad,Ht:5.6,Wt:55.0,Address:Address [doorNo=17, street=3rd cross, city=Blr, state=KA, country=IND, pincode=560043]
Address [doorNo=17, street=3rd cross, city=Blr, state=KA, country=IND, pincode=560043]
Address [doorNo=10, street=4th cross, city=Balari, state=KA, country=IND, pincode=560023]


2nd way of creating object:
==========================
1. by using Class.forName("Fullyqualifiedclassnmae").newInstance();

this code will cause 3 exceptions 1. ClassNotFoundException , 2. IllegalArgumentException 3. InstantiationException
 so we should use this code usign try and catch blocks. 
 
   try {
		Person p4 = (Person) Class.forName("com.k7it.Person1").newInstance();
		System.out.println(p4);
	} catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
		e.printStackTrace();
	}
	
	here 
	newInstance(): is depecrecate method so its not advisible to use it. since its very old code or legacy code.
	
	
equals():
=========
before talking about equals() we will discuss on equals operator(==).

== (equals operator): this is one of the comparing operator in java , 
    it will compare 2 values and it will return one boolean return value either true or false. 
    in case of comparing any two primitive values or primitive ref variables if both values are same
    then it will return true else it will return false. 
    ex:
       int i = 10;
       int j = 10;
       int k = 15;

     sop( i == j )//true
     sop( i == k )//false 
     sop( 5 == 5 )//true 
     sop( 5 == 6 )//false 
     sop( 10 == i )//true
	 sop( k == 10) // false
	 
	 class Person {
	    int age;
		String name;
		Person(int age, String name){
		  this.age = age;
		  this.name = name;
		}
	 }
	 sop
	 Person p1 = new Person(10,"Java");// 1003 memory locations
	 Person p2 = new Person(15,"K7iT");//1004
	 Person p3 = new Person(10,"Java");/1005
	 Person p4 = p1;//
	 Person p5 = p2;
	 
	 sop( p1 == p2);// 1003 == 1004  false 
	 sop( p1 == p3);// 1003 == 1005  false
	 sop( p3 == p5);// false
	 sop( p4 == p1);// true
	 sop( p4 == p2);// false
	 sop( p5 == p2);// true
	 
	 incase of derived data type values or ref var comapring time equals operator will comapare based on
 	 memory location of corresponding objects , i.e if both ref vars are pointing to same memory location 
	 it will return true else it will return false.
	 
	 sop( new Person(25,"prasad") == new Person(25,"prasad"));// false
	 
	Person temp1  = new Person(25,"prasad"); // 1007
	Person temp2  = new Person(25,"prasad"); //1008
	
	 sop(temp1 == temp2);
	
   	 sop(p1 == 100);//false  // here we are comparing derived ref var with primitive value 
	 

euqal() method : as per the Object class equals() it will works as same as the equals operator, 
it means it will comapre 2 objects using object memory locations instead of comapring objects content.
 here one diff between == and euqal() is by using == operator we can comapre primitive and derived values,
 but by using equals() method we can compare only derived values. 

 syntax : public boolean equals(Object obj){
          // return p1.hashCode() == p2.hashCode();
          return this.hashCode() == obj.hashCode();
         }		 
		 
	 Person p1 = new Person(10,"Java");// 1003 memory locations
	 Person p2 = new Person(15,"K7iT");//1004
	 Person p3 = new Person(10,"Java");/1005
	 Person p4 = p1;//
	 Person p5 = p2;

     sop( p1.equals(p2) );// false 
	 sop( p1.equals(p3) );// false
	 sop( p3.equals(p5) );// false
	 sop( p4.equals(p1) );// true
	 sop( p4.equals(p2) );// false
	 sop( p5.equals(p2) );// true
	 
	 
	 class A{
	   
	   public boolean compare(A a1, A a2){
	      // this -> a3 
	     return a1.hashCode() == a2.hashCode();
	   }
	   
	    public boolean compare(A a){
	      // this -> a1 
	     return this.hashCode() == a.hashCode();
	   }
	    
	 }
	 
	 A a1 = new A();
	 A a2 = new A();
	 A a3 = new A();
	 A a4 = a1;
	 A a5 = a2;
	 
	 
	 a3.comapare(a1,a2); // false 
	 a1.comapare(a1,a2);// false 
	 a2.comapare(a1,a2);// false 
	 a3.comapare(a1,a4);// true
	 
	 a1.comapare(a2);// false 
	 a3.comapare(a1);// false 
	 a1.comapare(a4);// true 
	 a2.comapare(a5);// true 
	 a1.comapare(a1);// true
	 
	 
	but as a java developers we should not concentrate on object memory locations 
	 we should comapre based on content of the objects or values of the objects .
	
	if we want to comapre 2 objects based on thier values then we should override equals() method inside our class. 
	
	
	equals() override steps:
	=======================
	
	1. declare equals method in sub class same as object class 
	
	    public boolean equals(Object obj){
		}
	2. downcast parameter value into a corresponding sub class type. 
	     public boolean equals(Object obj){
		   Person p2 = (Person)obj;
		}
	3. then comapre each and every attribute values between this(current obj) object  and p2 object;
	   // this obj means by using which object u called equals().
	
	   public boolean equals(Object obj){
		   Person p2 = (Person)obj;
		   return (this.age == p2.age && this.name.equals(p2.name) );
		}
		
		 && - and operator
		 logical multification 
	     1 * 1 = 1
		 1 * 0 = 0
		 0 * 1 = 0
		 0 * 0 = 0
		 here 1 - true 0 - false
		  
		|| -> or operator
		logical addition 
		
		 1 + 1 = 1
		 1 + 0 = 1
		 0 + 1 = 1
		 0 + 0 = 0
		 here 1 - true 0 - false
		 
		 
		 package com.k7it;

public class Person {

	int age;
	String name;
	
	public Person(){
		
	}
	public Person(int age, String name) {
		super();
		this.age = age;
		this.name = name;
	}
	
	@Override
	public String toString() {
		return "Age:"+this.age+", Name:"+this.name+";
	}
    @Override	
	public boolean equals(Object obj) {
		Person p = (Person)obj;
		return ( this.age == p.age && this.name.equals(p.name) );
	}
	
	
}
		 
	 Person p1 = new Person(10,"Java");// 1003 memory locations
	 Person p2 = new Person(15,"K7iT");//1004
	 Person p3 = new Person(10,"Java");/1005
	 Person p4 = p1;//
	 Person p5 = p2;

     sop( p1.equals(p2) );// false 
	 sop( p1.equals(p3) );// true
	 sop( p3.equals(p5) );// false
	 sop( p4.equals(p1) );// true
	 sop( p4.equals(p2) );// false
	 sop( p5.equals(p2) );// true
	 sop( p3.equals(p4) );// true
	 
	 sop( p3.equals(new Person(10,"Java")) );// true
	 sop( new Person(10,"Java").equals(new Person(10,"Java")) );// true
	 sop( new Person(10,"MongoDB").equals(new Person(10,"Java")) );// false
	 
	 
	 hashCode() :  
		 ===========
		 hashCode method as per the object class it will return the object memory location in int format.
		 
		 syntax:
		     public int hashCode(){
				
			 }
			 
			 
			 Person p1 = new Person(10,"Java");// 1003 memory locations
			 Person p2 = new Person(15,"K7iT");//1004
			 Person p3 = new Person(10,"Java");/1005
			 Person p4 = p1;//
			 Person p5 = p2;
			 
			 sop( p1.hashCode() == p2.hashCode());// false 
			 sop( p1.hashCode() == p3.hashCode());// false
			 sop( p3.hashCode() == p5.hashCode());// false
			 sop( p4.hashCode() == p1.hashCode());// true
			 sop( p4.hashCode() == p2.hashCode());// false
			 sop( p5.hashCode() == p2.hashCode());// true
			 
			 
			in java equals method and hashCode methods are having same contract towards 2 objects,
			both of the methods we will use to comapre 2 objects and find both are same or not. 
			
			so end of the comaparizen both the methods should give same result towards any 2 objects comapring. 
			
			But here if we see p1 to p3 ref variables comaparing by euqals and hashCode methods, 
			we are getting different outputs. mainly   
			
			sop( p1.hashCode() == p3.hashCode());// false.
			
			sop( p1.equals(p3));// true.
		

		
			hashCode :
			============
			 sop( p1.hashCode() == p3.hashCode());// false
			 
			 equals:
			 ======
			  sop( p1.equals(p3) );// true
			  
			  why bzc equals method comaparing 2 objects based on content, 
			  but hashCode method comapring 2 objects based on memory location. 
			  
			  so now if want hashCode also comapare objects based on content then we shoould override
			  the hashCode method in our class as same as equals method. 
			  
			  hashCode() override steps:
			  ==========================
			  0. override hashcode() as per object class syntax 
                  public int hashCode(){
				  
				  }			  
			  
			  1. convert each primitive attribute values into a string values.
			    
			      String ageStr = ""+this.age;	// ""+10 ="10"
							or 
			      String ageStr = String.valueOf(this.age);	// "10"
				  
				  String htStr = ""+ this.ht;// ""+ 5.5 = "5.5" 
				  or 
			      String htStr = String.valueOf(this.ht);	// 5.5 -> "5.5"
				  
			  2. get hashCode for all attributes using String class hashCode(). 
			   why bzc inside string class euqal and hashCode already overriden based on content. 

					int ageHashCode =  ageStr.hashCode();
					int nameHashCode  = name.hashCode();
		     3. add all attributes hashCode as sum and return that sum value as hashCode for our object.
			    
				return  ageHashCode+nameHashCode;
				
				public int hashCode(){
				
				  String ageStr =  ""+age;
				  int ageHashCode =  ageStr.hashCode(); // 10, 15
				  int nameHashCode  = name.hashCode();// 34, 47
				  
				  return ageHashCode + nameHashCode;// 44, 62
				}
			
			
			 
			 sop( p1.hashCode() == p2.hashCode());// 44 == 62 false 
			 sop( p1.hashCode() == p3.hashCode());// 44 == 44 true
			 sop( p3.hashCode() == p5.hashCode());// 44 == 62 false
			 sop( p4.hashCode() == p1.hashCode());// 44 == 44 true
			 sop( p4.hashCode() == p2.hashCode());// 44 == 62 false
			 sop( p5.hashCode() == p2.hashCode());// 62 == 62 true
			 
			 
			 sop( p1.equals(p2) );// false 
			 sop( p1.equals(p3) );// true
			 sop( p3.equals(p5) );// false
			 sop( p4.equals(p1) );// true
			 sop( p4.equals(p2) );// false
			 sop( p5.equals(p2) );// true
			 
			 original hash codes:
			 ======================
			p1 hashCode:-1112722211
			p2 hashCode:1282878722
			p3 hashCode:-1112722211
			p4 hashCode:-1112722211
			p5 hashCode:1282878722
			
			
			package com.k7it;

import java.util.Objects;

//@Deprecated
public class Person {

	int age;
	String name;
	double ht;
	double wt;
	
	public Person(){
		
	}
	public Person(int age, String name, double ht, double wt) {
		super();
		this.age = age;
		this.name = name;
		this.ht = ht;
		this.wt = wt;
	}
	
	@Override
	public String toString() {
		return "Age:"+this.age+", Name:"+this.name+", Ht:"+this.ht+", Wt:"+this.wt;
	}
    @Override	
	public boolean equals(Object obj) {
		Person p = (Person)obj;
		return (this.age == p.age && this.name.equals(p.name) && this.ht == p.ht && this.wt == p.wt);
	}
    
    @Override
    public int hashCode() {
    	// convert primitive to string 
    	String strAge = ""+age;
    	String strHt = String.valueOf(ht);
    	String strWt = ""+wt;
    	
    	// generate hashcode for each attributes 
    	int ageHashCode = strAge.hashCode();
    	int nameHashCode = name.hashCode();
    	int htHashCode = strHt.hashCode();
    	int wtHashCode = strWt.hashCode();
    	
    	return (ageHashCode + nameHashCode + htHashCode + wtHashCode);
    	
    	
    }
	
}

 Note: if we dont want to override hashcode and equals with our own logic , we can use eclipse help to generate 
       hashCode equals methods logic .
	    rt_click -> source -> generate hashCode and equals -> select required attributes -> finish
		
	@Override
	public int hashCode() {
		return Objects.hash(age, ht, name, wt);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		return age == other.age && Double.doubleToLongBits(ht) == Double.doubleToLongBits(other.ht)
				&& Objects.equals(name, other.name) && Double.doubleToLongBits(wt) == Double.doubleToLongBits(other.wt);
	}
	
	
	here  Objects.hash(age, ht, name, wt) : Objects is one of the class which is introduced in java 1.7, 
	it will used to generate hash code for required fields by using hash(Object... obj)

    hash(Object... obj):  here Object... is called as var args parameter, it means it will takes multiple values 
     into a single variable like arrays. 
      if we pass multiple values , while reading we should use index for reading values. 
      index will start from 0 to n-1 	
      count will start from 1 to n 
      
      example :
         int add(int... v) {
		 
		   return v[0]+v[1]+v[2];
		 
		 }	

 in above method we are reading 3 values from single variable, so while calling we shoould pass at least min 3 values, 
   or more than 3 values fine, we will use 3 values and we will ignore remaining values . 

 -> if we pass less than 3 values, then we will IndexOutOfBoundException. it means specified index there is no value 

  if we want to avoid this kind of exception we can use for loop to read the values from var args.

        so by using for loop we can generate dynamic index based on number of values in var args.
	     
		 int add(int... v) {
		   int sum = 0;
		  for(int i=0;i < v.length; i++){ //v.length -> 7
		     sum = sum+ v[i];
		  }
		   return sum;
		 }
	
	   add(10,20,5,6,7,8,2);
	     i =0 , 0<7 -> true sum = 0+v[0] = sum = 0+10= 10
		i++ i =1, 1<7 -> trur sum = sum+v[1] = 10+20 = 30
		i++ i =2, 2<7 -> trur sum = sum+v[2] = 30+5 = 35
		i++ i =3, 3<7 -> trur sum = sum+v[3] = 35+6 = 41
		i++ i =4, 4<7 -> trur sum = sum+v[4] = 41+7 = 48
		i++ i =5, 5<7 -> trur sum = sum+v[5] = 48+8 = 56
		i++ i =6, 6<7 -> trur sum = sum+v[6] = 56+2 = 58
		i++ i =7, 7<7 -> false 
		
			
			package com.k7it;

public class A {

	

	static int add(int... v) {

		//return v[0] + v[1] + v[2];
		
		int sum =0;
		for(int i =0;i< v.length;i++) {
			sum = sum+v[i];
		}
		return sum;

	}

	public static void main(String... args) {
		int sum = add(10, 20, 30, 40);
		System.out.println(sum);
		int sum1 = add(10, 20);
		System.out.println(sum1);
		int sum3 = add();
		System.out.println(sum3);
	}
}


output :
100
30
0
			
			clone():
			=======
			using clone() we can create duplicate object for original objects.
			while creating duplicates we can get 2 types of duplicate objects 
			
			deep copy : 
			==========
			if both the objects are 100% disjoint that is called as deep copy,
			it means after cloning if we do any modification on one object it will not effect on another object.
			
			shallow copy :  
			===============
			if both the objects are not 100% disjoint that is called as as shallow copy, 
			it means after cloning if we do any modification on one object it will  effect on another object.
			
			as per the Object class clone method it will give deep copy in case 
			 our class object having only primitive data type attributes or string data type attributes. 
			
			if our class is having any of derived data type attributes like address attribute in person class.
			then Object class clone method will give the shallow copy. 
			
			even though if our class having derived attributes if we want to get the deep copy 
			   then we should override the clone method in our class. 
			
			
			the creating duplicate object is a illegal activity in java , by default jav will not support the clone operation,
 			when we try to create duplicate object using clone() we will get the error message from compiler like "CloneNotSupprtedException".
			 but even though it is a illegal if we want to do it due to some reasons as per the requirements then we shoould take one special recomendations from Clonnable interface.
		 it means we should implements the Clonable interface to our class or making our class is a subclass to clonable interface. 
			
			note:
			======
			syntax:
			
			protected Object clone()throws CloneNotSupportedException{
			
			}
		here clone method is a protected method so after inheritance it will become private member and specific to our class,
		so we can't access clone() out side of our class using our class object / ref var. 
	
	
	class Person{
	  int age;
	  String name;
	}
	class PersonManager{
	   public static void main(String... args){
	      
		  Person p1 = new Person(10,"Java");
		  Person p1Dup =  p1.clone();// CTE clone() act like private member inside Person class.
	   }
	}
  	if we want to use clone() out side of the class means , then we should provide one public method inside our class,
	in that public method we can use clone() method internally,
	
	then from outside of class we can call the public method.
		
		
		class Person{
		/// attributes
		// methods
		//constructors 
		
			 public Person getClone(){
			 
			// Person dup =  this.clone();// CTE  here clone() return type is Object class tpye, so we need to do down cast to Person
			  Person dup = (Person) this.clone();//CTE 
			 
			  return dup;
			 
			 } 
			 
			 or 
			 
			 public Person getClone(){
			
			  return Person) this.clone();//CTE  with CloneNotSupprtedException
			 
			 } 
		 }
		 
		 here this.clone(); will give the CloneNotSupprtedException, it is a checktype exception , 
		 if we want to use this.clone();  we should keep that code inside try and catch block 
		 or add throws key near our method signature with CloneNotSupprtedException type it means
		 we are throwing same exception to our users or callers. 
		 
       1. 		

         public Person getClone(){
		 
			 try{
			    return (Person) this.clone();
			 } catch(CloneNotSupprtedException e){
			     e.printStackTrace();
			 }
			 return null;
		 }  	   
		2. 
		public Person getClone() throws CloneNotSupportedException {
        
			return (Person) this.clone();

		}
		
		
		Example:
		=========
		
		class Person{
			String name;
			int age;		
		
		    Person(int age, String name){
			  this.age  = age;
			  this.name = name;
			}
			public Person getClone() throws CloneNotSupportedException {
        
			   return (Person) this.clone();

		   }
		   // override toString()
		 }
		
		class PersonManager{
		 public static void main(String args[])throws CloneNotSupportedException{
		   Person p1 = new Person(10,"Java");
		   
		   Person p1Dup = p1.getClone();
		   
		   p1.age = 40;
		   
		   p1Dup.name = "K7iT";
		   
		   System.out.println(p1); //  age:40, name:Java
		   System.out.println(p1Dup);// age:10, name:K7iT 
		
		}
		}
		
			if we run this code we will get the error like this : this error is RunTimeError
			why bzc clonening operation is one of the unscure operation, so by default JRE will not 
			allow, even though compile success.  so we will get error again .
		
	Exception in thread "main" java.lang.CloneNotSupportedException: com.k7it.Person
	at java.base/java.lang.Object.clone(Native Method)
	at ObjectclassDemo/com.k7it.Person.getClone(Person.java:92)
	at ObjectclassDemo/com.k7it.ObjectClsDemo.main(ObjectClsDemo.java:87)
	
	if we want to fix this problem then we should implements Clonable interface to our class. or
   	make our class is a subclass to Clonable interface.
	
	public class Person  implements Cloneable{
	
	}
	
	then again execute main().
	output : 	
		   System.out.println(p1); //  age:40, name:Java
		   System.out.println(p1Dup);// age:10, name:K7iT 
		 here p1 and p1Dup are 100% disjoint objects, it means these are deep copy objects. 
		
	
		in case Person class having address class type attribute:	
		
			class Address{
			      int doorNo;
				  String street;
				  String city;
				  String state;
				  String country;
				  int pincode;
				  
				  //constructors with no arg and parameters 
				  // toString override
				  public String toString(){
				    return "DoorNo:"+doorNo+", Street:"+street+", City:"+city+", State:"+state+
					        ", Country:"+country+", PinCode:"+pincode
				  }
			 }		
		 class Person{
			String name;
			int age;
            Address address;			
		
		    Person(int age, String name, Address address){
			  this.age  = age;
			  this.name = name;
			  this.address = address;
			}
			public Person getClone() throws CloneNotSupportedException {
        
			   return (Person) this.clone();

		   }
		   // override toString()
		   public String toString(){
		     return "Name:"+name+",Age:"+age+",Address:{"+address+"}";
		   }
		 }
		
		class PersonManager{
		public static void main(String args[])throws CloneNotSupportedException{
		   
		   Address a1 = new Address(17,"3rd cross","Bangalore","KA", "India",560043);
		   
		   Person p1 = new Person(10,"Java",a1);
		   
		   Person p1Dup = p1.getClone();
		   
		   System.out.println("Before Update");
		   
		   System.out.println("Original:"+p1); //  name: Java, age:40 address :{doorNo:28,Street:,City:,State:,Country:,PinCode:}
		   System.out.println("Duplicate:"+p1Dup);// age:10, name:K7iT 
		   
		   p1Dup.age = 40;
		   
		   p1Dup.name = "K7iT";
		   
		   p1Dup.address.doorNo = 28;
		   
		   p1Dup.address.city = "Tirupathi";
		   
		   System.out.println("After Update");
		   System.out.println("Original:"+p1); //  name: Java, age:40 address :{doorNo:28,Street:,City:,State:,Country:,PinCode:}
		   System.out.println("Duplicate:"+p1Dup);// age:10, name:K7iT 
		
		}
		}
		
		if we run this code we will get the error like this :
		
	Exception in thread "main" java.lang.CloneNotSupportedException: com.k7it.Person
	at java.base/java.lang.Object.clone(Native Method)
	at ObjectclassDemo/com.k7it.Person.getClone(Person.java:92)
	at ObjectclassDemo/com.k7it.ObjectClsDemo.main(ObjectClsDemo.java:87)
	
	if we want to fix this problem then we should implements Clonable interface to our class. or
   	make our class is a subclass to Clonable interface.
	
	public class Person  implements Cloneable{
	
	}
	
	then again execute main().
	
Before Update
Original:Name:Java,Age:10,Address:{DoorNo:17, Street:3rd cross, City:Bangalore, State:KA, Country:India, PinCode:560043}
Duplicate:Name:Java,Age:10,Address:{DoorNo:17, Street:3rd cross, City:Bangalore, State:KA, Country:India, PinCode:560043}
After Update
Original:Name:Java,Age:10,Address:{DoorNo:28, Street:3rd cross, City:Tirupathi, State:KA, Country:India, PinCode:560043}
Duplicate:Name:K7iT,Age:40,Address:{DoorNo:28, Street:3rd cross, City:Tirupathi, State:KA, Country:India, PinCode:560043}



here both objects are same even after update and before update.  

Note: here i am chaning values in dup obj address attribute but it effected in original obj as well. 
   it means clone() created shallow copy in case of derived attribute case. 
   
   

if we want to achive deep copy even though we are using derived attributes :
===========================================================================

then we shoould override the clone method inside our class. 

while override we shoould create one extract object for each derived attributes and 
 copy original attribute values into extract object as it is. 
 then set that extra object to duplicate person object.

here we need to create extra address class obj and dup original obj address values into new address obj as it is,
  then set new address obj  to duplicate person obj as duplicate address.

    @Override
	public Person clone() throws CloneNotSupportedException {
		// 1st create dup object using  super class clone and do the down casting into our class type
		Person dupPerson  =  (Person) super.clone();
		//2. create new object for derived attribute class type. i.e  Address class our case 
		//
		Address dupAdd =  new Address();
		//3. dump all address class obj values from old obj to new obj.
		dupAdd.setDoorNo(this.getAddress().getDoorNo());
		dupAdd.setStreet(this.getAddress().getStreet());
		dupAdd.setCity(this.getAddress().getCity());
		dupAdd.setState(this.getAddress().getState());
		dupAdd.setCountry(this.getAddress().getCountry());
		dupAdd.setPincode(this.getAddress().getPincode());
		// 4. reset the dupPerosn derived attribute (address class attribute )with new address class object 
		dupPerson.setAddress(dupAdd);
		// repeat 2, 3 and 4 steps for every derived attributes if there anything in our class.
//		
//		Dog dupDog =  new Dog();
//		dupDog.setName(dupPerson.getDog().getName());
//		dupPerson.setDog(dupDog);
		
		//5. return duplicate obj as retunr value of clone method.
		return dupPerson;
	}
	
	
	Example:
	
	package com.k7it.clone;


public class Person implements Cloneable{
	String name;
	int age;
    Address address;			

    Person(int age, String name, Address address){
	  this.age  = age;
	  this.name = name;
	  this.address = address;
	}
	public Person getClone() throws CloneNotSupportedException {

	   return (Person) this.clone();

   }
	
	
	@Override
	public Person clone() throws CloneNotSupportedException {
		
		 // create duplicate obj using super clone
		Person dupPerson = (Person)super.clone();
		
		//create new dup address using original address obj
		Address dupAdd = new Address(this.address.doorNo, this.address.street, this.address.city, this.address.state,
				this.address.country, this.address.pincode);
		
		dupPerson.address = dupAdd;
		
		return dupPerson;
	}
   // override toString()
   public String toString(){
     return "Name:"+name+",Age:"+age+",Address:{"+address+"}";
   }
   
   
 }


package com.k7it.clone;

public class PersonManager {
	
	public static void main(String args[])throws CloneNotSupportedException{
		
		
		   
		   Address a1 = new Address(17,"3rd cross","Bangalore","KA", "India",560043);
		   
		   Person p1 = new Person(10,"Java",a1);
		   
		  // if(p1 instanceof Cloneable) {
			//   System.out.println("Allow Clone");
		  // }else {
			//   throw new CloneNotSupportedException();
		  // }
		   
		   Person p1Dup = p1.getClone();
		   
		   System.out.println("Before Update");
		   
		   System.out.println("Original:"+p1); //  name: Java, age:40 address :{doorNo:28,Street:,City:,State:,Country:,PinCode:}
		   System.out.println("Duplicate:"+p1Dup);// age:10, name:K7iT 
		   
		   p1Dup.age = 40;
		   
		   p1Dup.name = "K7iT";
		   
		   p1Dup.address.doorNo = 28;
		   
		   p1Dup.address.city = "Tirupathi";
		   
		   System.out.println("After Update");
		   System.out.println("Original:"+p1); //  name: Java, age:40 address :{doorNo:28,Street:,City:,State:,Country:,PinCode:}
		   System.out.println("Duplicate:"+p1Dup);// age:10, name:K7iT 
		
		}
}

	
	output:
	========
	Allow Clone
	Before Update
	Original:Name:Java,Age:10,Address:{DoorNo:17, Street:3rd cross, City:Bangalore, State:KA, Country:India, PinCode:560043}
	Duplicate:Name:Java,Age:10,Address:{DoorNo:17, Street:3rd cross, City:Bangalore, State:KA, Country:India, PinCode:560043}
	After Update
	Original:Name:Java,Age:10,Address:{DoorNo:17, Street:3rd cross, City:Bangalore, State:KA, Country:India, PinCode:560043}
	Duplicate:Name:K7iT,Age:40,Address:{DoorNo:28, Street:3rd cross, City:Tirupathi, State:KA, Country:India, PinCode:560043}

	 here after override we are geeting deep copy objects even though we have derived attributes.
	 it means if update any thing in dup obj its not effected on original obj. 
	 
	 
	
	Note: clone operation is a unscure operation, so by default JRE will not allow us to   
	create cloning operation, but due to some reasons if we want to perform cloning operation 
	then  we should take Clonable interface recomendations by just implements clonable interface 
	into our class. 
	  
	  class Person implements Clonable{
	   // class body
	  }
	
	here 
	Clonable:
	==============
	Clonable interface is  called as marker interface, its having some special priority with JRE,
	what ever the classes are implements clonable interface those classes will get the 
	special permissions from JRE to perform clonable operation. 
	
	i.e  clonable/ marker interface will send one mark to JRE like 
	hey JRE this class is belongs to my catogory please allow him for clonning operation. 
	
	 if( this instanceOf Clonable ){
	        allow clone
	 }else{
	     throw new CloneNotSupportedException();
	   } 
	   

here instanceOf: will verify left side value is belongs to right class Type or is the left side value   
                 having IS-A relation or Co-relationship with Right side  Class Type. 
				 
				  if left side value having relation with right class then it will return boolean true 
				  else it will return false.
				  
            p1 instanceOf Clonable  -> Clonable c  = p1; ->  c= new Person();- > true 
			
			p1 instanceOf Person -> true
			
			a1 instanceOf Person -> CTE  there is no relation betwee person and address
			
	Note : in java for every unscure operation there is a one coresponding marker interface like 
	       for 
		    cloning operation -> Clonable interface
		    serialization operation -> Serializable interface. 
			these are the 2 major unsecure operations in java. 
			
			
			if we want to perform this unscure operation we need those interface help or recomendations by using' implements key word
			
			marker interface : every marker interface empty interface, it menas from marker interface we wont
			        get any members, but we will some special permissions from JRE, by satisfying 
					instanceof if statement inside jre code . 
					
					interface Clonable{
					// marker interface
					}
	  
					interface Serializable{
					// marker interface
					}	

    
				interface X{
				 // this empty interface but  not a marker interface
				}
				
				Note: every marker interface is a empty interface 
				  but not every empty interface is a marker interface.
					
					
			

  last method in object class is 
  
  finalized(): 
  ================
  
  Syntax:
  =======
    protected void finalized(){
	 //
	}
	
	this method is defined for garbage collector purposr not for developer purpose.
	
	GC : Gorbage collector, it will clean up the heap memory, if there is any aboarned objects 
	   or unused objects or orphan objects or nullyfy objects. 
	
	GC will works based on mark and sweep alorigtham ,
	
	mark : when ever gc will come for 1st execuiton if it find any unused objects , 
	 it will mark that object and it will call the finalized() by using that null object. 
	
	what is the resposibility of finalized : it will verify is there any open resources inside
 	that object or is any important resources are using inside that object, 
	if there is any resources like that it will close that resources and add to available list.
	
	
	for example : if take database connections objects or input stream objects or
	output stream object etc , these objects are available only limited count. 
	
user 	used resources   available resources
	
	0                    10
	2					  8
	5					  5
	10					  0
	8					  2
	
	in case of db connections we will maitain only limited connections 
	
	from our class we can use data base connections to save or fetch data from database
	
	   1. open connection  - when open no of available connections will reduce by 1
	   2. use connection obj and get data or save data or delete data 
	   3. close connection. : when we will close the connection it will add to available connection list and count will increase one 
	   
	   
	Person {
	
	savePerson(){
	
	   // open connection();
	   
	   con.save(person obj);
	   
	   con.close();
	}
	
	updatePerson(){
	
	   // open connection();
	   
	   con.update(person obj);
	   // here might be some exception came close connection operation not excuted.
	   con.close();
	}
	
	deletePerson(){
	
	   // open connection();
	   
	   con.delete(person obj);
	   // he forgot to close the connection. 
	   con.close();
	}
	
	}
	
	Employee {
	
	}
	
	
	
	
	finalized(): 
	===========
		finalized method resposibility is recheck inside aboarned object before deleting
	either that object is using any open resources objects, if it find any open resources
	then finalized method will close those connections and add to available list and it will go. 
	
	then when next time gc will come for excution he will delete that object. 
	
	when gc will come first time excution it will mark the object and it will call finalized method
	and it will go. 
	
	then finalized() will come for execuiton, it will  check and close and add into to available list if
     	any open resources are inside that object.
		
		 data base operations:
		 ======================
		CRUD:  create , read, update, delete
		CURD:  create, update, read, delete
		
		wait
		notify
		notifyAll 
		 these 3 methods used for threads purpose, so  we will discuss in thread concepts.                  
		 
		 
		 
		
	
	
		 
		 